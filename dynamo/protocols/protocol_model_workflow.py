# **************************************************************************
# *
# * Authors:    David Herreros Calero (dherreros@cnb.csic.es)
# *             Scipion Team (scipion@cnb.csic.es)
# *
# *  BCU, Centro Nacional de Biotecnologia, CSIC
# *
# * This program is free software; you can redistribute it and/or modify
# * it under the terms of the GNU General Public License as published by
# * the Free Software Foundation; either version 2 of the License, or
# * (at your option) any later version.
# *
# * This program is distributed in the hope that it will be useful,
# * but WITHOUT ANY WARRANTY; without even the implied warranty of
# * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# * GNU General Public License for more details.
# *
# * You should have received a copy of the GNU General Public License
# * along with this program; if not, write to the Free Software
# * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
# * 02111-1307  USA
# *
# *  All comments concerning this program package may be sent to the
# *  e-mail address 'scipion@cnb.csic.es'
# *
# **************************************************************************
from enum import Enum
from os.path import abspath
from pyworkflow import BETA
from pyworkflow.object import String
from pyworkflow.protocol import params
from pwem.protocols import EMProtocol
from pyworkflow.utils import removeExt
from tomo.constants import BOTTOM_LEFT_CORNER
from tomo.objects import SetOfMeshes, Coordinate3D
from tomo.protocols import ProtTomoBase
from ..convert.convert import eulerAngles2matrix
from dynamo import Plugin, M_GENERAL_DES, M_GENERAL_WITH_BOXES_DES, M_GENERAL_NAME, M_SURFACE_NAME, \
    M_ELLIPSOIDAL_VESICLE_NAME, M_GENERAL_WITH_BOXES_NAME, M_DIPOLE_SET_NAME, M_DIPOLE_SET_DES, M_SURFACE_DES, \
    M_VESICLE_NAME, M_VESICLE_DES, M_ELLIPSOIDAL_VESICLE_DES, M_MARKED_ELLIP_VESICLE_NAME, M_MARKED_ELLIP_VESICLE_DES, \
    MB_BY_LEVELS, MB_ELLIPSOIDAL, MB_GENERAL, MB_GENERAL_BOXES, MB_VESICLE, MB_ELLIPSOIDAL_MARKED

# Model types mapping
from ..utils import getCatalogFile

MODEL_CHOICES = [M_ELLIPSOIDAL_VESICLE_NAME, M_SURFACE_NAME, M_GENERAL_NAME]

# Model types encoding
M_VESICLE = 0
M_SURFACE = 1
M_GENERAL = 2

# Dynamo model names mapping
dynModelsDict = {
    MB_BY_LEVELS: M_SURFACE,
    MB_VESICLE: M_VESICLE,
    MB_ELLIPSOIDAL: M_VESICLE,
    MB_ELLIPSOIDAL_MARKED: M_VESICLE,
    MB_GENERAL: M_GENERAL,
    MB_GENERAL_BOXES: M_GENERAL,
}


class OutputsModelWf(Enum):
    meshes = SetOfMeshes


class DynamoModelWorkflow(EMProtocol, ProtTomoBase):
    """Apply a model workflow to a SetOfMeshes generated by Dynamo Boxing protocol. This workflow will use the
    models created by the user to create the corresponding cropping meshes needed to extract the crop points"""

    _label = 'model workflow'
    _devStatus = BETA
    _possibleOutputs = OutputsModelWf

    def __init__(self, **kwargs):
        EMProtocol.__init__(self, **kwargs)
        self.meshes = None

    # --------------------------- DEFINE param functions ----------------------
    def _defineParams(self, form):
        form.addSection(label='Input')
        form.addParam('inputMeshes', params.PointerParam,
                      pointerClass='SetOfMeshes',
                      label="Input Meshes",
                      important=True,
                      help="Input Meshes that will be used to create the cropping geometry and "
                           "to extract the crop points")
        form.addParam('boxSize', params.IntParam,
                      default=0,
                      label='Box size',
                      important=True)

        form.addSection('Model parameters')
        form.addLine('Available models:')
        form.addLine('Description --> ', help=self._genModelsDescriptionMsg())
        form.addLine('Notation --> ', help=self._genModelsNotationMsg())
        group = form.addGroup('Specific for %s model (skip this if no models of this type were created)' % M_GENERAL_NAME)
        group.addParam('orientMesh', params.PointerParam,
                       pointerClass='SetOfMeshes',
                       label="Orientation Meshes (opt.)",
                       allowsNull=True,
                       help="Specify if you will use a different SetOfMeshes to impart orientation to "
                            "the *Input Meshes* provided before. If not provided, no directional information "
                            "will be given to the output coordinates.")
        group.addParam('orientType', params.EnumParam,
                       choices=MODEL_CHOICES[:-1],
                       default=M_VESICLE,
                       label='Model type for *Orientation Meshes*',
                       help='Select the type of model defined in the Tomograms.')

        group = form.addGroup('Common to multiple models')
        group.addParam('meshParameter', params.IntParam,
                       default=5,
                       label='Mesh parameter [EV][S][GE][GS]',
                       help='Intended mesh parameter for the "mesh" that supports the depiction of the model')
        group.addParam('maxTr', params.IntParam,
                       default=100000,
                       label="Maximun number of triangles [EV][S][GE][GS]",
                       help='Maximum number of triangles allowed during generation of a depiction mesh')
        group.addParam('cropping', params.IntParam,
                       default=10,
                       label="Cropping parameter [EV][S]",
                       help='Intended mesh parameter for the "crop_mesh" that defined a cropping '
                            'geometry on a surface')
        group.addParam('subDivision', params.IntParam,
                       default=2,
                       label="Number of Subdivision steps [S][GS]",
                       help="Specifiy the number of times the Mesh geometry will be subdivided. This will increase the "
                            "number of triangles in the mesh, making it smoother. However, it will also increase the "
                            "number of cropping points")

    # --------------------------- INSERT steps functions ----------------------
    def _insertAllSteps(self):
        self._initialize()
        for tomoId in self.presentTomoIds:
            # Get the models associated to the current tomogram
            modelsDict = self.inputMeshes.get().getUniqueValues(['_dynModelName', '_dynModelFile', '_groupId'],
                                                                where="_tomoId == '%s'" % tomoId)
            for modelName, modelFile, vesicleId in zip(modelsDict['_dynModelName'], modelsDict['_dynModelFile'],
                                                       modelsDict['_groupId']):
                self._insertFunctionStep(self.applyWorkflowStep, tomoId, modelName, modelFile, vesicleId)
                self._insertFunctionStep(self.convertOutputStep, tomoId)

        self._insertFunctionStep(self.createOutputStep)

    # --------------------------- STEPS functions -----------------------------
    def _initialize(self):
        presentIdsListOfDicts = self.inputMeshes.get().aggregate(["MAX"], "_volId", ["_volId", "_tomoId"])
        self.presentTomoIds = [d['_tomoId'] for d in presentIdsListOfDicts]
        self.precedentsTsIdList = {tomo.getTsId(): tomo for tomo in self.inputMeshes.get().getPrecedents()}
        self.savePath = self._getExtraPath()
        self.cataloguePath = abspath(removeExt(self.inputMeshes.get()._dynCatalogue.get()))

    def applyWorkflowStep(self, tomoId, modelName, modelFile, vesicleId):
        commandsFile = self.writeMatlabFile(tomoId, modelName, modelFile, vesicleId)
        args = ' %s' % commandsFile
        self.runJob(Plugin.getDynamoProgram(), args, env=Plugin.getEnviron())

    def convertOutputStep(self, tomoId):
        if not self.meshes:
            # Create the output set
            precedents = self.inputMeshes.get().getPrecedents()
            self.meshes = SetOfMeshes.create(self._getPath(), template='meshes%s.sqlite')
            self.meshes.setPrecedents(precedents)
            self.meshes.setSamplingRate(precedents.getSamplingRate())
            self.meshes.setBoxSize(self.boxSize.get())
            self.meshes._dynCatalogue = String(getCatalogFile(self._getExtraPath()))  # Extended attribute

        tomo = self.precedentsTsIdList[tomoId]
        with open(self.getMeshResultFile(tomoId), 'r') as coordFile:
            for line in coordFile:
                coord = Coordinate3D()
                values = line.replace('\n', '').split('\t')
                coord.setVolume(tomo)
                coordinates = float(values[0]), float(values[1]), float(values[2])
                angles = float(values[3]), float(values[4]), float(values[5])
                coord.setPosition(*coordinates, BOTTOM_LEFT_CORNER)
                matrix = eulerAngles2matrix(*angles, 0, 0, 0)  # There are no shifts at this point
                coord.setMatrix(matrix)
                coord.setGroupId(int(values[6]))
                # Extended attributes
                coord._dynModelName = String(values[7])
                coord._dynModelFile = String(values[8])
                self.meshes.append(coord)

    def createOutputStep(self):
        self._defineOutputs(**{OutputsModelWf.meshes.name: self.meshes})
        self._defineSourceRelation(self.inputMeshes, self.meshes)
        self._updateOutputSet(OutputsModelWf.meshes.name, self.meshes, state=self.meshes.STREAM_CLOSED)

    # --------------------------- DEFINE utils functions ----------------------
    def writeMatlabFile(self, tomoId, modelName, modelFile, vesicleId):
        codeFilePath = self._getExtraPath('modelWf_%s_%s.m' % (tomoId, modelName))
        modelType = self._getModelType(modelName)
        # outPath = removeBaseExt(self.inputMeshes.get().getPrecedents()[volId].getFileName())
        if modelType == M_VESICLE:
            content = self.genVesicleCmdFileContents(tomoId, modelName, modelFile, vesicleId)
        elif modelType == M_SURFACE:
            content = self.genSCmdFileContents(tomoId, modelFile, vesicleId)
        # elif modelType == M_GENERAL:
        #     if self.orientType.get() == M_ELLIPSOIDAL and self.orientMesh.get():
        #         content = self.genGECmdFileContents(volId, outPath)
        #     elif self.orientType.get() == M_SURFACE and self.orientMesh.get():
        #         content = self.genGSCmdFileContents(volId, outPath)
        #     else:
        #         content = self.genGCmdFileContents(volId, outPath)
        with open(codeFilePath, 'w') as codeFid:
            codeFid.write(content)

        return codeFilePath

    def genVesicleCmdFileContents(self, tomoId, modelName, modelFile, vesicleId):
        # Load the current Dynamo model
        content = self._genMCode4ReadDynModel(modelFile)
        # Let Dynamo approximate the geometry based on the points annotated in the boxing protocol
        content += "m.approximateGeometryFromPoints()\n"
        # Mesh creation steps (some of which are specific for each sub-model of type vesicle)
        content += "m.mesh_parameter = %i\n" % self.meshParameter.get()
        content += "m.crop_mesh_parameter = %i\n" % self.cropping.get()
        content += "m.mesh_maximum_triangles = %i\n" % self.maxTr.get()
        if modelName == MB_ELLIPSOIDAL:
            content += "m.createMesh()\n"
        content += "m.updateCrop()\n"
        content += "m.grepTable()\n"
        # Format and write the output data in a text file that will be read in the step create output
        content += self._genMCode4ReadAndSaveData(vesicleId, modelFile, self.getMeshResultFile(tomoId))
        return content

    def genSCmdFileContents(self, tomoId, modelFile, vesicleId):
        # Load the current Dynamo model
        content = self._genMCode4ReadDynModel(modelFile)
        # Mesh creation steps
        content += "m.mesh_parameter=%i\n" % self.meshParameter.get()
        content += "m.crop_mesh_parameter=%i\n" % self.cropping.get()
        content += "m.mesh_maximum_triangles=%i\n" % self.maxTr.get()
        content += "m.subdivision_iterations=%i\n" % self.subDivision.get()
        content += "m.createMesh()\n"
        content += "m.refineMesh()\n"
        content += "m.createCropMesh()\n"
        content += "m.refineCropMesh()\n"
        content += "m.updateCrop()\n"
        content += "m.grepTable()\n"
        # Format and write the output data in a text file that will be read in the step create output
        content += self._genMCode4ReadAndSaveData(vesicleId, modelFile, self.getMeshResultFile(tomoId))
        return content

    def genGECmdFileContents(self, tomoId, modelName, modelFile, vesicleId):
        content = "path = '%s'\n" % self.cataloguePath
        content += "m = dread('%s')\n" % abspath(modelFile)  # Load the model created in the boxing protocol
        content += "m_o=dread(fullfile(modelFile_o(k).folder,modelFile_o(k).name))\n"
        # Let Dynamo approximate the geometry based on the points annotated in the boxing protocol
        content += "m_o.approximateGeometryFromPoints()\n"

        content += "m_o.mesh_parameter=%i\n" % self.meshParameter.get()
        content += "m_o.mesh_maximum_triangles=%i\n" % self.maxTr.get()
        content += "m_o.createMesh\n"
        content += "t=m.grepTable()\n"
        content += "t=dpktbl.triangulation.fillTable(m_o.mesh,t)\n"
        content += "crop_points=[crop_points; [t(:,24:26) modelId*ones(length(m.crop_points),1)]]\n"
        content += "crop_angles=[crop_angles; [t(:,7:9) modelId*ones(length(m.crop_angles),1)]]\n"
        content += "end\n"
        content += "writematrix(crop_points,fullfile(savePath,outPoints),'Delimiter',' ')\n"
        content += "writematrix(crop_angles,fullfile(savePath,outAngles),'Delimiter',' ')\n"
        content += "exit\n"
        return content

    def genGSCmdFileContents(self, volId, outPath):
        content = "path='%s'\n" % self.cataloguePath
        content += "path_o='%s'\n" % self.orientationMesh
        content += "crop_points=[]\n"
        content += "crop_angles=[]\n"
        content += "modelId=0\n"
        content += "outFile='%s'\n" % outPath
        content += "savePath='%s'\n" % self.savePath
        content += "outPoints=[outFile '.txt']\n"
        content += "outAngles=['angles_' outFile '.txt']\n"
        content += "modelFile=dir(fullfile(path,'tomograms','volume_%i','models'))\n" % volId
        content += "modelFile=modelFile(~ismember({modelFile.name},{'.','..'}))\n"
        content += "modelFile_o=dir(fullfile(path_o,'tomograms','volume_%i','models'))\n" % volId
        content += "modelFile_o=modelFile_o(~ismember({modelFile_o.name},{'.','..'}))\n"
        content += "for k=1:length(modelFile)\n"
        content += "modelId=modelId+1\n"
        content += "m=dread(fullfile(modelFile(k).folder,modelFile(k).name))\n"
        content += "m_o=dread(fullfile(modelFile_o(k).folder,modelFile_o(k).name))\n"
        content += "m_o.mesh_parameter=%i\n" % self.meshParameter.get()
        content += "m_o.mesh_maximum_triangles=%i\n" % self.maxTr.get()
        content += "m_o.subdivision_iterations=%i\n" % self.subDivision.get()
        content += "if isempty(m_o.center)\n"
        content += "m_o.center=mean(m_o.points)\n"
        content += "end\n"
        content += "m_o.createMesh()\n"
        content += "m_o.refineMesh()\n"
        content += "t=m.grepTable()\n"
        content += "t=dpktbl.triangulation.fillTable(m_o.mesh,t)\n"
        content += "crop_points=[crop_points; [t(:,24:26) modelId*ones(length(m.crop_points),1)]]\n"
        content += "crop_angles=[crop_angles; [t(:,7:9) modelId*ones(length(m.crop_angles),1)]]\n"
        content += "end\n"
        content += "writematrix(crop_points,fullfile(savePath,outPoints),'Delimiter',' ')\n"
        content += "writematrix(crop_angles,fullfile(savePath,outAngles),'Delimiter',' ')\n"
        content += "exit\n"
        return content

    def genGCmdFileContents(self, volId, outPath):
        content = "path='%s'\n" % self.cataloguePath
        content += "crop_points=[]\n"
        content += "crop_angles=[]\n"
        content += "modelId=0\n"
        content += "outFile='%s'\n" % outPath
        content += "savePath='%s'\n" % self.savePath
        content += "outPoints=[outFile '.txt']\n"
        content += "outAngles=['angles_' outFile '.txt']\n"
        content += "modelFile=dir(fullfile(path,'tomograms','volume_%i','models'))\n" % volId
        content += "modelFile=modelFile(~ismember({modelFile.name},{'.','..'}))\n"
        content += "for k=1:length(modelFile)\n"
        content += "modelId=modelId+1\n"
        content += "m=dread(fullfile(modelFile(k).folder,modelFile(k).name))\n"
        content += "t=m.grepTable()\n"
        content += "crop_points=[crop_points; [t(:,24:26) modelId*ones(length(m.crop_points),1)]]\n"
        content += "crop_angles=[crop_angles; [t(:,7:9) modelId*ones(length(m.crop_angles),1)]]\n"
        content += "end\n"
        content += "writematrix(crop_points,fullfile(savePath,outPoints),'Delimiter',' ')\n"
        content += "writematrix(crop_angles,fullfile(savePath,outAngles),'Delimiter',' ')\n"
        content += "exit\n"
        return content

    @staticmethod
    def _genModelsNotationMsg():
        modelsHelp = '- %s [EV]\n' % M_ELLIPSOIDAL_VESICLE_NAME
        modelsHelp += '- %s [S]\n' % M_SURFACE_NAME
        modelsHelp += '- %s [G]\n\n' % M_GENERAL_NAME
        modelsHelp += '- %s model specific cases:\n' % M_GENERAL_NAME
        modelsHelp += '   - If oriented with an ellipsoidal vesicle model mesh [GE]\n'
        modelsHelp += '   - If oriented with a surface model mesh [GS]\n'
        modelsHelp += '   - Parameters corresponding to models not present in your picking data can be ignored\n'
        return modelsHelp

    @staticmethod
    def _genModelsDescriptionMsg():
        modelsHelp = '*%s*:\n\n' % M_GENERAL_NAME.upper()
        modelsHelp += '\t1) *%s*: %s\n\n' % (M_GENERAL_NAME, M_GENERAL_DES)
        modelsHelp += '\t2) *%s*: %s\n\n\n' % (M_GENERAL_WITH_BOXES_NAME, M_GENERAL_WITH_BOXES_DES)
        modelsHelp += '*%s*:\n%s\n\n\n' % (M_DIPOLE_SET_NAME.upper(), M_DIPOLE_SET_DES)
        modelsHelp += '*%s*:\n%s\n\n\n' % (M_SURFACE_NAME.upper(), M_SURFACE_DES)
        modelsHelp += '*%s*:\n\n' % M_VESICLE_NAME.upper()
        modelsHelp += '\t1) *%s*: %s\n\n' % (M_VESICLE_NAME, M_VESICLE_DES)
        modelsHelp += '\t2) *%s*: %s\n\n' % (M_ELLIPSOIDAL_VESICLE_NAME, M_ELLIPSOIDAL_VESICLE_DES)
        modelsHelp += '\t3) *%s*: %s\n\n\n' % (M_MARKED_ELLIP_VESICLE_NAME, M_MARKED_ELLIP_VESICLE_DES)
        return modelsHelp

    @staticmethod
    def _getModelType(modelName):
        # Map the Dynamo model names into the protocol encoding model values
        return dynModelsDict[modelName]

    def getMeshResultFile(self, tomoId):
        return abspath(self._getExtraPath('%s.txt' % tomoId))

    @staticmethod
    def _genMCode4ReadDynModel(modelFile):
        """MATLAB code to read a model file from Dynamo"""
        return "m = dread('%s')\n" % abspath(modelFile)  # Load the model created in the boxing protocol

    @staticmethod
    def _genMCode4ReadAndSaveData(vesicleId, modelFile, outputFile):
        """MATLAB code to format and write the output data in a text file that will be read in the step create output.
        The column headers of the generated file are:
        coordX, coordY, coordZ, rot, tilt, psi, vesicleId, modelName, modelFile"""
        content = "coordsMatrix = m.crop_points\n"
        content += "anglesMatrix = m.crop_angles\n"
        content += "nParticles = size(coordsMatrix, 1)\n"
        content += "for row=1:nParticles\n"
        content += "cRow = (100*coordsMatrix(row,:))/100\n"  # Leave only two decimals for the coordinates
        content += "aRow = (100*anglesMatrix(row,:))/100\n"  # The same for the angles
        content += "writecell({cRow(1), cRow(2), cRow(3), aRow(1), aRow(2), aRow(3), %i, m.name, '%s'}, '%s', " \
                   "'WriteMode','append', 'Delimiter', 'tab')\n" % (vesicleId, modelFile, outputFile)
        content += "end\n"
        return content
    # --------------------------- DEFINE INFO functions ----------------------
    # def _methods(self):
    #     methodsMsgs = ["*Model Type*: %s" % MODEL_CHOICES[self.modelType.get()]]
    #     if self.modelType.get() == M_ELLIPSOIDAL:
    #         if self.auto.get():
    #             methodsMsgs.append("*Geometry Detection*: auto")
    #         else:
    #             methodsMsgs.append("*Geometry Detection*: manual")
    #             methodsMsgs.append("    *Center*: [%s]" % self.center.get())
    #             methodsMsgs.append("    *Semiaxes Radius*: [%s]" % self.radius.get())
    #         methodsMsgs.append("*Mesh parameter*: %d" % self.meshParameter.get())
    #         methodsMsgs.append("*Maximum number triangles*: %d" % self.maxTr.get())
    #         methodsMsgs.append("*Cropping parameter*: %d" % self.cropping.get())
    #     elif self.modelType.get() == M_SURFACE:
    #         methodsMsgs.append("*Model Type*: Surface")
    #         methodsMsgs.append("*Mesh parameter*: %d" % self.meshParameter.get())
    #         methodsMsgs.append("*Maximum number triangles*: %d" % self.maxTr.get())
    #         methodsMsgs.append("*Cropping parameter*: %d" % self.cropping.get())
    #         methodsMsgs.append("*Number of subdivision steps*: %d" % self.subDivision.get())
    #     elif self.modelType.get() == M_GENERAL:
    #         if self.orientMesh.get() is None:
    #             methodsMsgs.append("Particles extracted without orientation")
    #         else:
    #             if self.orientType.get() == M_ELLIPSOIDAL:
    #                 methodsMsgs.append("*Orientation Model Type*: Ellipsoidal Vesicle")
    #                 if self.auto.get():
    #                     methodsMsgs.append("*Geometry Detection*: auto")
    #                 else:
    #                     methodsMsgs.append("*Geometry Detection*: manual")
    #                     methodsMsgs.append("    *Center*: [%s]" % self.center.get())
    #                     methodsMsgs.append("    *Semiaxes Radius*: [%s]" % self.radius.get())
    #                 methodsMsgs.append("*Mesh parameter*: %d" % self.meshParameter.get())
    #                 methodsMsgs.append("*Maximum number triangles*: %d" % self.maxTr.get())
    #             elif self.orientType.get() == M_SURFACE:
    #                 methodsMsgs.append("*Orientation Model Type*: Surface")
    #                 methodsMsgs.append("*Mesh parameter*: %d" % self.meshParameter.get())
    #                 methodsMsgs.append("*Maximum number triangles*: %d" % self.maxTr.get())
    #                 methodsMsgs.append("*Number of subdivision steps*: %d" % self.subDivision.get())
    #     return methodsMsgs

    def _summary(self):
        summary = []
        if self.getOutputsSize() >= 1:
            for _, outCoords in self.iterOutputAttributes():
                summary.append("Output *%s*:" % outCoords.getNameId().split('.')[1])
                summary.append("    * Particle box size: *%s*" % self.boxSize.get())
                summary.append("    * Coordinates defined by geometry: *%s*" %
                               outCoords.getSize())
        else:
            summary.append("Output coordinates not ready yet.")
        return summary

    def _validate(self):
        errorMsg = []
        # Only sets of meshes generated using the Dynamo picking protocol are accepted (they must contain
        # an attribute named '_dynCatalogue')
        if not getattr(self.inputMeshes.get(), '_dynCatalogue', None):
            errorMsg.append('Only sets of meshes generated using the Dynamo picking protocol are accepted')
        return errorMsg
